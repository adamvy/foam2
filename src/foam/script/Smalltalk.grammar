grammar foam.script.SmalltalkRecognizer = (

commentCharacter = character - '"';
  (* any character other than a double quote *)

comment = '"', {commentCharacter}, '"';
optionalWhitespace = {whitespaceCharacter | comment};
whitespace = (whitespaceCharacter | comment), optionalWhitespace;
letterOrDigit =
  decimalDigit
  | letter;
identifier = (letter | '_'), {(letterOrDigit | '_')};
reference = identifier;
constantReference =
                     'nil'
                     | 'false'
                     | 'true';
pseudoVariableReference =
                     'self'
                     | 'super'
                     | 'thisContext';
             (* 'thisContext' is not defined by the ANSI standard, but is widely used anyway *)
reservedIdentifier =
                     pseudoVariableReference
                     | constantReference;

bindableIdentifier = identifier - reservedIdentifier;
unaryMessageSelector = identifier;
keyword = identifier, ':';
keywordMessageSelector = keyword, {keyword};
binarySelectorChar = '~' | '!' | '@' | '%' | '&' | '*' | '-' | '+' | '=' | '|' | '\' | '<' | '>' | ',' | '?' | '/';
binaryMessageSelector = binarySelectorChar, [binarySelectorChar];
integerLiteral = ['-'], unsignedIntegerLiteral;
unsignedIntegerLiteral =
  decimalIntegerLiteral
  | radix, 'r', baseNIntegerLiteral;
decimalIntegerLiteral = decimalDigit, {decimalDigit};
radix = decimalIntegerLiteral;
baseNIntegerLiteral = letterOrDigit, {letterOrDigit};
scaledDecimalLiteral = ['-'], decimalIntegerLiteral, ['.', decimalIntegerLiteral], 's', [decimalIntegerLiteral];
floatingPointLiteral = ['-'], decimalIntegerLiteral, ('.', decimalIntegerLiteral, [exponent] | exponent);
exponent = ('e' | 'd' | 'q'), [['-'], decimalIntegerLiteral];
characterLiteral = '$', character;
stringLiteral = '''', {stringLiteralCharacter | ''''''}, '''';
             (* to embed a single quote character in a string literal, use two consecutive single quotes *)
stringLiteralCharacter = character - '''';
             (* any character other than a single quote *)
symbolInArrayLiteral =
                    unaryMessageSelector - constantReference
                     | keywordMessageSelector
                     | binaryMessageSelector;
symbolLiteral = '#', (symbolInArrayLiteral | constantReference | stringLiteral);
arrayLiteral =
                     objectArrayLiteral
                     | byteArrayLiteral;
objectArrayLiteral = '#', nestedObjectArrayLiteral;
nestedObjectArrayLiteral = '(', optionalWhitespace, [literalArrayElement, {whitespace, literalArrayElement}], optionalWhitespace, ')';
literalArrayElement =
                     literal - blockLiteral
                     | nestedObjectArrayLiteral
                     | symbolInArrayLiteral
                     | constantReference;
byteArrayLiteral = '#[', optionalWhitespace, [unsignedIntegerLiteral, {whitespace, unsignedIntegerLiteral}], optionalWhitespace,']';
     (* the preceding production rules would usually be handled by the lexical analyzer;
         the following production rules would usually be handled by the parser *)
formalBlockArgumentDeclaration = ':', bindableIdentifier;
formalBlockArgumentDeclarationList = formalBlockArgumentDeclaration, {whitespace, formalBlockArgumentDeclaration};

blockLiteral = '[', [optionalWhitespace, formalBlockArgumentDeclarationList, optionalWhitespace, '|'], executableCode, optionalWhitespace, ']';
literal = constantReference
                     | integerLiteral
                     | scaledDecimalLiteral
                     | floatingPointLiteral
                     | characterLiteral
                     | stringLiteral
                     | symbolLiteral
                     | arrayLiteral
                     | blockLiteral;
nestedExpression = '(', statement, optionalWhitespace, ')';
operand =
                     literal
                     | reference
                     | nestedExpression;
unaryMessage = unaryMessageSelector;
unaryMessageChain = {optionalWhitespace, unaryMessage};
binaryMessageOperand = operand, unaryMessageChain;
binaryMessage = binaryMessageSelector, optionalWhitespace, binaryMessageOperand;
binaryMessageChain = {optionalWhitespace, binaryMessage};
keywordMessageArgument = binaryMessageOperand, binaryMessageChain;
keywordMessageSegment = keyword, optionalWhitespace, keywordMessageArgument;
keywordMessage = keywordMessageSegment, {optionalWhitespace, keywordMessageSegment};
messageChain =
                     unaryMessage, unaryMessageChain, binaryMessageChain, [keywordMessage]
                     | binaryMessage, binaryMessageChain, [keywordMessage]
                     | keywordMessage;
cascadedMessage = ';', optionalWhitespace, messageChain;
expression = operand, [optionalWhitespace, messageChain, {optionalWhitespace, cascadedMessage}];
assignmentOperation = optionalWhitespace, bindableIdentifier, optionalWhitespace, ':=';
statement = {assignmentOperation}, optionalWhitespace, expression;
methodReturnOperator = optionalWhitespace, '^';
finalStatement = [methodReturnOperator], statement;
localVariableDeclarationList = optionalWhitespace, '|', optionalWhitespace, [bindableIdentifier, {whitespace, bindableIdentifier}], optionalWhitespace, '|';
executableCode = [localVariableDeclarationList], [{statement, optionalWhitespace, '.'}, finalStatement, ['.']];

unaryMethodHeader = unaryMessageSelector;
binaryMethodHeader = binaryMessageSelector, optionalWhitespace, bindableIdentifier;
keywordMethodHeaderSegment = keyword, optionalWhitespace, bindableIdentifier;
keywordMethodHeader = keywordMethodHeaderSegment, {whitespace, keywordMethodHeaderSegment};
methodHeader =
                      unaryMethodHeader
                      | binaryMethodHeader
                      | keywordMethodHeader;
methodDeclaration = optionalWhiteSpace, methodHeader, executableCode;

)
